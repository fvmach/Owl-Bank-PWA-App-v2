// src/CodeBlock.tsx
import { Box as Box2, safelySpreadBoxProps } from "@twilio-paste/box";
import { SyntaxHighlighter } from "@twilio-paste/syntax-highlighter-library";
import * as React3 from "react";

// src/CodeBlockTheme.ts
import { css } from "@twilio-paste/styling-library";
import { useTheme } from "@twilio-paste/theme";
var getPasteSyntaxTheme = (maxLines) => {
  const theme = useTheme();
  return css({
    'code[class*="language-"]': {
      color: "#d6deeb",
      fontFamily: "fontFamilyCode",
      textAlign: "left",
      whiteSpace: "pre",
      wordSpacing: "normal",
      wordBreak: "normal",
      wordWrap: "normal",
      lineHeight: "1.5",
      fontSize: "1em",
      MozTabSize: "4",
      OTabSize: "4",
      tabSize: "4",
      WebkitHyphens: "none",
      MozHyphens: "none",
      msHyphens: "none",
      hyphens: "none"
    },
    'pre[class*="language-"]': {
      color: "white",
      fontFamily: "fontFamilyCode",
      textAlign: "left",
      whiteSpace: "pre",
      wordSpacing: "normal",
      wordBreak: "normal",
      wordWrap: "normal",
      lineHeight: "1.5",
      fontSize: "1em",
      MozTabSize: "4",
      OTabSize: "4",
      tabSize: "4",
      WebkitHyphens: "none",
      MozHyphens: "none",
      msHyphens: "none",
      hyphens: "none",
      margin: "0",
      overflow: "auto",
      background: "inherit",
      display: "-webkit-box",
      WebkitLineClamp: `${maxLines}`,
      WebkitBoxOrient: "vertical",
      width: "100%"
    },
    'pre[class*="language-"]::-moz-selection': {
      textShadow: "none",
      background: "inherit"
    },
    'pre[class*="language-"] ::-moz-selection': {
      textShadow: "none",
      background: "inherit"
    },
    'code[class*="language-"]::-moz-selection': {
      textShadow: "none",
      background: "inherit"
    },
    'code[class*="language-"] ::-moz-selection': {
      textShadow: "none",
      background: "inherit"
    },
    'pre[class*="language-"]::selection': {
      textShadow: "none",
      background: "inherit"
    },
    'pre[class*="language-"] ::selection': {
      textShadow: "none",
      background: "inherit"
    },
    'code[class*="language-"]::selection': {
      textShadow: "none",
      background: "inherit"
    },
    'code[class*="language-"] ::selection': {
      textShadow: "none",
      background: "inherit"
    },
    ':not(pre) > code[class*="language-"]': {
      color: "white",
      background: "#011627",
      padding: "0.1em",
      borderRadius: "0.3em",
      whiteSpace: "normal"
    },
    comment: {
      color: "rgb(136, 145, 170)",
      fontStyle: "italic"
    },
    linenumber: {
      color: "colorTextInverseWeak",
      fontStyle: "none"
    },
    prolog: {
      color: "rgb(99, 119, 119)",
      fontStyle: "italic"
    },
    cdata: {
      color: "rgb(99, 119, 119)",
      fontStyle: "italic"
    },
    punctuation: {
      color: "rgb(199, 146, 234)"
    },
    ".namespace": {
      color: "rgb(178, 204, 214)"
    },
    deleted: {
      color: "rgba(239, 83, 80, 0.56)",
      fontStyle: "italic"
    },
    symbol: {
      color: "rgb(128, 203, 196)"
    },
    property: {
      color: "rgb(128, 203, 196)"
    },
    tag: {
      color: "rgb(127, 219, 202)"
    },
    operator: {
      color: "rgb(127, 219, 202)"
    },
    keyword: {
      color: "rgb(127, 219, 202)"
    },
    boolean: {
      color: "rgb(255, 88, 116)"
    },
    number: {
      color: "rgb(247, 140, 108)"
    },
    constant: {
      color: "rgb(130, 170, 255)"
    },
    function: {
      color: "rgb(130, 170, 255)"
    },
    builtin: {
      color: "rgb(130, 170, 255)"
    },
    char: {
      color: "rgb(130, 170, 255)"
    },
    selector: {
      color: "rgb(199, 146, 234)",
      fontStyle: "italic"
    },
    doctype: {
      color: "rgb(199, 146, 234)",
      fontStyle: "italic"
    },
    "attr-name": {
      color: "rgb(173, 219, 103)",
      fontStyle: "italic"
    },
    inserted: {
      color: "rgb(173, 219, 103)",
      fontStyle: "italic"
    },
    string: {
      color: "rgb(173, 219, 103)"
    },
    url: {
      color: "rgb(173, 219, 103)"
    },
    entity: {
      color: "rgb(173, 219, 103)"
    },
    ".language-css .token.string": {
      color: "rgb(173, 219, 103)"
    },
    ".style .token.string": {
      color: "rgb(173, 219, 103)"
    },
    "class-name": {
      color: "rgb(255, 203, 139)"
    },
    atrule: {
      color: "rgb(255, 203, 139)"
    },
    "attr-value": {
      color: "rgb(255, 203, 139)"
    },
    regex: {
      color: "rgb(214, 222, 235)"
    },
    important: {
      color: "rgb(214, 222, 235)",
      fontWeight: "bold"
    },
    variable: {
      color: "rgb(214, 222, 235)"
    },
    bold: {
      fontWeight: "bold"
    },
    italic: {
      fontStyle: "italic"
    }
  })(theme);
};

// src/CopyButton.tsx
import { Box } from "@twilio-paste/box";
import { Button } from "@twilio-paste/button";
import { useClipboard } from "@twilio-paste/clipboard-copy-library";
import { CopyIcon } from "@twilio-paste/icons/esm/CopyIcon";
import { ScreenReaderOnly } from "@twilio-paste/screen-reader-only";
import { Tooltip, useTooltipState } from "@twilio-paste/tooltip";
import * as React from "react";
var getCopyButtonText = (labelBefore, labelAfter) => {
  return (copied) => {
    return copied ? labelAfter : labelBefore;
  };
};
var CopyButton = ({
  text,
  i18nCopyLabelBefore = "Copy code block",
  i18nCopyLabelAfter = "Copied!",
  element = "COPY_BUTTON",
  copyTextFormatter,
  ...props
}) => {
  const tooltipState = useTooltipState();
  const [tooltipText, setTooltipText] = React.useState(i18nCopyLabelBefore);
  const isFirstRender = React.useRef(true);
  const getText = React.useMemo(() => {
    return getCopyButtonText(i18nCopyLabelBefore, i18nCopyLabelAfter);
  }, [i18nCopyLabelBefore, i18nCopyLabelAfter]);
  const clipboard = useClipboard({ copiedTimeout: 1500 });
  const handleCopy = React.useCallback(() => {
    const formattedText = copyTextFormatter ? copyTextFormatter(text) : text;
    clipboard.copy(formattedText);
  }, [text, copyTextFormatter, clipboard]);
  React.useEffect(() => {
    setTooltipText(getText(clipboard.copied));
  }, [clipboard.copied, getText]);
  React.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    setTimeout(() => {
      tooltipState.unstable_update();
    }, 0);
  }, [tooltipState]);
  return /* @__PURE__ */ React.createElement(Tooltip, { text: tooltipText, state: tooltipState, element: `${element}_TOOLTIP` }, /* @__PURE__ */ React.createElement(Button, { variant: "inverse", size: "icon_small", onClick: handleCopy, element, ...props }, /* @__PURE__ */ React.createElement(Box, { as: "span" }, /* @__PURE__ */ React.createElement(CopyIcon, { decorative: true }), /* @__PURE__ */ React.createElement(Box, { as: "span", "aria-live": "polite" }, /* @__PURE__ */ React.createElement(ScreenReaderOnly, null, tooltipText)))));
};
CopyButton.displayName = "CopyButton";

// src/ExternalLinkButton.tsx
import { Button as Button2 } from "@twilio-paste/button";
import { LinkExternalIcon } from "@twilio-paste/icons/esm/LinkExternalIcon";
import { ScreenReaderOnly as ScreenReaderOnly2 } from "@twilio-paste/screen-reader-only";
import { Tooltip as Tooltip2, useTooltipState as useTooltipState2 } from "@twilio-paste/tooltip";
import * as React2 from "react";
var ExternalLinkButton = ({
  i18nLinkLabel = "Open code block in new page",
  href,
  element = "EXTERNAL_LINK",
  ...props
}) => {
  const tooltipState = useTooltipState2();
  const tooltipText = i18nLinkLabel;
  const isFirstRender = React2.useRef(true);
  React2.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    tooltipState.hide();
    setTimeout(() => tooltipState.show(), 0);
  }, [tooltipText]);
  return /* @__PURE__ */ React2.createElement(Tooltip2, { text: tooltipText, element: `${element}_TOOLTIP` }, /* @__PURE__ */ React2.createElement(Button2, { as: "a", variant: "inverse", size: "icon_small", href, element, target: "_blank", ...props }, /* @__PURE__ */ React2.createElement(LinkExternalIcon, { decorative: true }), /* @__PURE__ */ React2.createElement(ScreenReaderOnly2, null, i18nLinkLabel)));
};
ExternalLinkButton.displayName = "ExternalLinkButton";

// src/CodeBlock.tsx
var CodeBlockVariantStyles = {
  "single-line": {
    gridTemplateColumns: "1fr auto",
    gridTemplateAreas: '"code-block button-group"',
    columnGap: "space40",
    borderRadius: "borderRadius20",
    paddingY: "space60"
  },
  "multi-line": {
    gridTemplateRows: "auto 1fr",
    gridTemplateAreas: '"button-group" "code-block"',
    rowGap: "space20",
    paddingTop: "space50",
    paddingBottom: "space90"
  }
};
var CodeBlock = React3.forwardRef(
  ({
    element = "CODE_BLOCK",
    language,
    code,
    variant = "multi-line",
    showLineNumbers,
    wrapLines,
    maxLines,
    externalLink,
    i18nCopyLabelAfter,
    i18nCopyLabelBefore,
    i18nLinkLabel,
    copyTextFormatter,
    ...props
  }, ref) => {
    return /* @__PURE__ */ React3.createElement(
      Box2,
      {
        ref,
        element,
        variant,
        ...safelySpreadBoxProps(props),
        backgroundColor: "colorBackgroundBodyInverse",
        paddingX: "space70",
        display: "grid",
        ...CodeBlockVariantStyles[variant]
      },
      /* @__PURE__ */ React3.createElement(
        Box2,
        {
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          columnGap: "space40",
          justifyContent: variant === "multi-line" ? "flex-end" : void 0,
          gridArea: "button-group"
        },
        /* @__PURE__ */ React3.createElement(Box2, null, /* @__PURE__ */ React3.createElement(
          CopyButton,
          {
            element: `${element}_COPY_BUTTON`,
            text: code,
            i18nCopyLabelAfter,
            i18nCopyLabelBefore,
            copyTextFormatter
          }
        )),
        externalLink && /* @__PURE__ */ React3.createElement(Box2, null, /* @__PURE__ */ React3.createElement(
          ExternalLinkButton,
          {
            href: externalLink,
            element: `${element}_EXTERNAL_LINK`,
            i18nLinkLabel
          }
        ))
      ),
      /* @__PURE__ */ React3.createElement(Box2, { element: `${element}_CONTENT`, display: "flex", alignItems: "center", overflowX: "auto", gridArea: "code-block" }, /* @__PURE__ */ React3.createElement(
        SyntaxHighlighter,
        {
          language,
          style: getPasteSyntaxTheme(maxLines),
          showLineNumbers,
          wrapLongLines: wrapLines,
          wrapLines: true
        },
        code
      ))
    );
  }
);
CodeBlock.displayName = "CodeBlock";

// src/CodeBlockHeader.tsx
import { Box as Box3, safelySpreadBoxProps as safelySpreadBoxProps2 } from "@twilio-paste/box";
import * as React4 from "react";
var CodeBlockHeader = React4.forwardRef(
  ({ children, element = "CODE_BLOCK_HEADER", as = "h3", ...props }, ref) => /* @__PURE__ */ React4.createElement(
    Box3,
    {
      ...safelySpreadBoxProps2(props),
      ref,
      element,
      as,
      backgroundColor: "colorBackgroundInverseStrong",
      color: "colorTextInverse",
      paddingY: "space50",
      paddingX: "space70",
      margin: "space0",
      borderTopLeftRadius: "borderRadius20",
      borderTopRightRadius: "borderRadius20",
      fontWeight: "fontWeightSemibold",
      fontSize: "fontSize30"
    },
    children
  )
);
CodeBlockHeader.displayName = "CodeBlockHeader";

// src/CodeBlockTab.tsx
import { Tab } from "@twilio-paste/tabs";
import * as React5 from "react";
var CodeBlockTab = React5.forwardRef(
  ({ children, element = "CODE_BLOCK_TAB", ...props }, ref) => {
    return /* @__PURE__ */ React5.createElement(Tab, { element, ref, ...props }, children);
  }
);
CodeBlockTab.displayName = "CodeBlockTab";

// src/CodeBlockTabList.tsx
import { Box as Box5, safelySpreadBoxProps as safelySpreadBoxProps3 } from "@twilio-paste/box";
import { css as css2, styled } from "@twilio-paste/styling-library";
import { TabsContext } from "@twilio-paste/tabs";
import { TabPrimitiveList } from "@twilio-paste/tabs-primitive";
import * as React8 from "react";

// src/OverflowButton.tsx
import { Box as Box4 } from "@twilio-paste/box";
import { ChevronLeftIcon } from "@twilio-paste/icons/esm/ChevronLeftIcon";
import { ChevronRightIcon } from "@twilio-paste/icons/esm/ChevronRightIcon";
import { useTheme as useTheme2 } from "@twilio-paste/theme";
import React6 from "react";
var Styles = {
  color: "colorTextIconInverse",
  _hover: {
    color: "colorTextInverse",
    cursor: "pointer"
  }
};
var OverflowButton = ({
  onClick,
  position,
  visible,
  element = "CODE_BLOCK_TAB_LIST",
  showShadow
}) => {
  const theme = useTheme2();
  const Chevron = position === "left" ? ChevronLeftIcon : ChevronRightIcon;
  if (!visible && position === "right")
    return null;
  const determineShadow = () => {
    if (visible && showShadow) {
      if (position === "left")
        return theme.shadows.shadowLeftInverse;
      return theme.shadows.shadowRightInverse;
    }
    return void 0;
  };
  return /* @__PURE__ */ React6.createElement(
    Box4,
    {
      onClick,
      "aria-hidden": true,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "sizeBase60",
      padding: "space10",
      position: "relative",
      boxShadow: determineShadow(),
      element: `${element}_OVERFLOW_BUTTON_${position.toUpperCase()}`,
      cursor: visible ? "pointer" : "none",
      zIndex: "zIndex10",
      ...Styles
    },
    visible && /* @__PURE__ */ React6.createElement(Chevron, { decorative: true })
  );
};
OverflowButton.displayName = "OverflowButton";

// src/utlis.ts
import React7 from "react";
var useElementsOutOfBounds = () => {
  const [elementOutOBoundsLeft, setElementOutOfBoundsLeft] = React7.useState(null);
  const [elementOutOBoundsRight, setElementOutOfBoundsRight] = React7.useState(null);
  const determineElementsOutOfBounds = (scrollContainer, listContainer) => {
    if (scrollContainer && listContainer) {
      const currentScrollContainerRightPosition = scrollContainer?.getBoundingClientRect().right;
      const currentScrollContainerXOffset = scrollContainer?.getBoundingClientRect().x;
      let leftOutOfBounds = null;
      let rightOutOfBounds = null;
      listContainer.childNodes.forEach((tab) => {
        const { x, right } = tab.getBoundingClientRect();
        const isSpanningView = x < currentScrollContainerXOffset && right > currentScrollContainerRightPosition;
        if (!isSpanningView) {
          if (Math.round(x) < Math.round(currentScrollContainerXOffset - 28)) {
            leftOutOfBounds = tab;
          }
          if (Math.round(right) > Math.round(currentScrollContainerRightPosition + 28) && !rightOutOfBounds) {
            rightOutOfBounds = tab;
          }
        }
        setElementOutOfBoundsLeft(leftOutOfBounds);
        setElementOutOfBoundsRight(rightOutOfBounds);
      });
    }
  };
  return { elementOutOBoundsLeft, elementOutOBoundsRight, determineElementsOutOfBounds };
};
var useShowShadow = () => {
  const [showShadow, setShowShadow] = React7.useState(false);
  let showShadowTimer;
  const handleShadow = () => {
    if (showShadowTimer) {
      window.clearTimeout(showShadowTimer);
    }
    setShowShadow(true);
    showShadowTimer = window.setTimeout(() => {
      setShowShadow(false);
    }, 500);
  };
  return { showShadow, handleShadow };
};
var handleScrollDirection = (direction, elementOutOBoundsLeft, elementOutOBoundsRight, scrollContainer) => {
  const elementToScrollTo = direction === "left" ? elementOutOBoundsLeft : elementOutOBoundsRight;
  if (scrollContainer && elementToScrollTo) {
    const elementRect = elementToScrollTo.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    const containerScrollLeft = scrollContainer.scrollLeft;
    const newScrollLeft = containerScrollLeft + (elementRect.left - containerRect.left) - containerRect.width / 2 + elementRect.width / 2;
    scrollContainer.scrollTo({ left: newScrollLeft, behavior: "smooth" });
  }
};

// src/CodeBlockTabList.tsx
var StyledTabList = styled.div(() => {
  return css2({
    overflowX: "auto",
    overflowY: "hidden",
    overflowScrolling: "touch",
    "@supports (-moz-appearance:none)": {
      paddingBottom: "0px",
      scrollbarWidth: "none"
    },
    "::-webkit-scrollbar": {
      height: 0
    },
    "::-webkit-scrollbar-track": {
      background: "transparent"
    }
  });
});
var CodeBlockTabList = React8.forwardRef(
  ({ children, element = "CODE_BLOCK_TAB_LIST", ...props }, ref) => {
    const tabContext = React8.useContext(TabsContext);
    const scrollableRef = React8.useRef(null);
    const listRef = React8.useRef(null);
    const { determineElementsOutOfBounds, elementOutOBoundsLeft, elementOutOBoundsRight } = useElementsOutOfBounds();
    const { handleShadow, showShadow } = useShowShadow();
    const handleScrollEvent = () => {
      handleShadow();
      determineElementsOutOfBounds(scrollableRef.current, listRef.current);
    };
    React8.useEffect(() => {
      if (scrollableRef.current && listRef.current) {
        scrollableRef.current.addEventListener("scroll", handleScrollEvent);
        window.addEventListener("resize", handleScrollEvent);
        determineElementsOutOfBounds(scrollableRef.current, listRef.current);
      }
    }, [scrollableRef.current, listRef.current]);
    React8.useEffect(() => {
      return () => {
        if (scrollableRef.current) {
          scrollableRef.current.removeEventListener("scroll", handleScrollEvent);
          window.removeEventListener("resize", handleScrollEvent);
        }
      };
    }, []);
    return /* @__PURE__ */ React8.createElement(TabPrimitiveList, { ...tabContext, as: Box5, ...props, element, ref }, /* @__PURE__ */ React8.createElement(Box5, { element: `${element}_CHILD_WRAPPER`, display: "flex" }, /* @__PURE__ */ React8.createElement(
      OverflowButton,
      {
        position: "left",
        onClick: () => handleScrollDirection("left", elementOutOBoundsLeft, elementOutOBoundsRight, scrollableRef.current),
        visible: Boolean(elementOutOBoundsLeft),
        element,
        showShadow
      }
    ), /* @__PURE__ */ React8.createElement(
      Box5,
      {
        ...safelySpreadBoxProps3(props),
        as: StyledTabList,
        ref: scrollableRef,
        display: "flex",
        flexWrap: "nowrap",
        element: `${element}_CHILD_SCROLL_WRAPPER`,
        overflowX: "auto",
        overflowY: "hidden",
        flexGrow: 1,
        width: "calc(100% - 60px)"
      },
      /* @__PURE__ */ React8.createElement(
        Box5,
        {
          whiteSpace: "nowrap",
          element: `${element}_CHILD`,
          display: "flex",
          borderBottomStyle: "solid",
          borderBottomWidth: "borderWidth10",
          borderBottomColor: "colorBorderInverseWeaker",
          ref: listRef,
          flexGrow: 1,
          columnGap: "space20"
        },
        children
      )
    ), /* @__PURE__ */ React8.createElement(
      OverflowButton,
      {
        position: "right",
        onClick: () => handleScrollDirection("right", elementOutOBoundsLeft, elementOutOBoundsRight, scrollableRef.current),
        visible: Boolean(elementOutOBoundsRight),
        element,
        showShadow
      }
    )));
  }
);
CodeBlockTabList.displayName = "CodeBlockTabList";

// src/CodeBlockTabPanel.tsx
import { TabPanel } from "@twilio-paste/tabs";
import * as React9 from "react";
var CodeBlockTabPanel = React9.forwardRef(
  ({ children, element = "CODE_BLOCK_TAB_PANEL", ...props }, ref) => {
    return /* @__PURE__ */ React9.createElement(TabPanel, { ...props, paddingTop: "space0", element, ref }, children);
  }
);
CodeBlockTabPanel.displayName = "CodeBlockTabPanel";

// src/CodeBlockWrapper.tsx
import { Box as Box6 } from "@twilio-paste/box";
import { Tabs } from "@twilio-paste/tabs";
import * as React10 from "react";
var CodeBlockWrapper = React10.forwardRef(
  ({ children, state, element = "CODE_BLOCK_WRAPPER" }, ref) => {
    return /* @__PURE__ */ React10.createElement(Tabs, { variant: "inverse", state }, /* @__PURE__ */ React10.createElement(
      Box6,
      {
        backgroundColor: "colorBackgroundInverseStrong",
        borderRadius: "borderRadius20",
        overflow: "hidden",
        element,
        ref
      },
      children
    ));
  }
);
CodeBlockWrapper.displayName = "CodeBlockWrapper";
export {
  CodeBlock,
  CodeBlockHeader,
  CodeBlockTab,
  CodeBlockTabList,
  CodeBlockTabPanel,
  CodeBlockWrapper
};
