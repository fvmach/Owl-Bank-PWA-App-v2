// src/InPageNavigation.tsx
import { Box as Box2, safelySpreadBoxProps } from "@twilio-paste/box";
import { css, styled } from "@twilio-paste/styling-library";
import * as React4 from "react";

// src/InPageNavigationContext.tsx
import * as React from "react";
var InPageNavigationContext = React.createContext({
  variant: "default",
  orientation: "horizontal"
});

// src/OverflowButton.tsx
import { Box } from "@twilio-paste/box";
import { ChevronLeftIcon } from "@twilio-paste/icons/esm/ChevronLeftIcon";
import { ChevronRightIcon } from "@twilio-paste/icons/esm/ChevronRightIcon";
import { useTheme } from "@twilio-paste/theme";
import React2 from "react";
var Styles = {
  color: "colorTextIcon",
  _hover: {
    color: "colorTextPrimaryStrongest",
    cursor: "pointer"
  }
};
var InverseStyles = {
  color: "colorTextIconInverse",
  _hover: {
    color: "colorTextInverse",
    cursor: "pointer"
  }
};
var OverflowButton = ({
  onClick,
  position,
  visible,
  element = "TAB_LIST",
  showShadow
}) => {
  const theme = useTheme();
  const { variant } = React2.useContext(InPageNavigationContext);
  const isInverse = variant === "inverse" || variant === "inverse_fullWidth";
  const Chevron = position === "left" ? ChevronLeftIcon : ChevronRightIcon;
  if (!visible)
    return null;
  const determineShadow = () => {
    if (showShadow) {
      if (position === "left")
        return isInverse ? theme.shadows.shadowLeftInverse : theme.shadows.shadowLeft;
      return isInverse ? theme.shadows.shadowRightInverse : theme.shadows.shadowRight;
    }
    return void 0;
  };
  return /* @__PURE__ */ React2.createElement(
    Box,
    {
      onClick,
      "aria-hidden": true,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: "sizeBase70",
      padding: "space20",
      boxShadow: determineShadow(),
      element: `${element}_OVERFLOW_BUTTON_${position.toUpperCase()}`,
      zIndex: "zIndex10",
      ...isInverse ? InverseStyles : Styles
    },
    /* @__PURE__ */ React2.createElement(Chevron, { decorative: true })
  );
};
OverflowButton.displayName = "OverflowButton";

// src/utils.ts
import React3 from "react";
var useElementsOutOfBounds = () => {
  const [elementOutOBoundsLeft, setElementOutOfBoundsLeft] = React3.useState(null);
  const [elementOutOBoundsRight, setElementOutOfBoundsRight] = React3.useState(null);
  const determineElementsOutOfBounds = (scrollContainer, listContainer) => {
    if (scrollContainer && listContainer) {
      const currentScrollContainerRightPosition = scrollContainer?.getBoundingClientRect().right;
      const currentScrollContainerXOffset = scrollContainer?.getBoundingClientRect().x;
      let leftOutOfBounds = null;
      let rightOutOfBounds = null;
      listContainer.childNodes.forEach((tab) => {
        const { x, right } = tab.getBoundingClientRect();
        const isSpanningView = x < currentScrollContainerXOffset && right > currentScrollContainerRightPosition;
        if (!isSpanningView) {
          if (Math.round(x) < Math.round(currentScrollContainerXOffset - 28)) {
            leftOutOfBounds = tab;
          }
          if (Math.round(right) > Math.round(currentScrollContainerRightPosition + 28) && !rightOutOfBounds) {
            rightOutOfBounds = tab;
          }
        }
        setElementOutOfBoundsLeft(leftOutOfBounds);
        setElementOutOfBoundsRight(rightOutOfBounds);
      });
    }
  };
  return { elementOutOBoundsLeft, elementOutOBoundsRight, determineElementsOutOfBounds };
};
var useShowShadow = () => {
  const [showShadow, setShowShadow] = React3.useState(false);
  let showShadowTimer;
  const handleShadow = () => {
    if (showShadowTimer) {
      window.clearTimeout(showShadowTimer);
    }
    setShowShadow(true);
    showShadowTimer = window.setTimeout(() => {
      setShowShadow(false);
    }, 500);
  };
  return { showShadow, handleShadow };
};
var handleScrollDirection = (direction, elementOutOBoundsLeft, elementOutOBoundsRight, scrollContainer) => {
  const elementToScrollTo = direction === "left" ? elementOutOBoundsLeft : elementOutOBoundsRight;
  if (scrollContainer && elementToScrollTo) {
    const elementRect = elementToScrollTo.getBoundingClientRect();
    const containerRect = scrollContainer.getBoundingClientRect();
    const containerScrollLeft = scrollContainer.scrollLeft;
    const newScrollLeft = containerScrollLeft + (elementRect.left - containerRect.left) - containerRect.width / 2 + elementRect.width / 2;
    scrollContainer.scrollTo({ left: newScrollLeft, behavior: "smooth" });
  }
};

// src/InPageNavigation.tsx
var StyledScrollWrapper = styled.div(() => {
  return css({
    overflowX: "auto",
    overflowY: "hidden",
    overflowScrolling: "touch",
    "@supports (-moz-appearance:none)": {
      paddingBottom: "0px",
      scrollbarWidth: "none"
    },
    "::-webkit-scrollbar": {
      height: 0
    },
    "::-webkit-scrollbar-track": {
      background: "transparent"
    }
  });
});
var InPageNavigation = React4.forwardRef(
  ({
    element = "IN_PAGE_NAVIGATION",
    variant = "default",
    orientation = "horizontal",
    marginBottom,
    hideBottomBorder = false,
    children,
    ...props
  }, ref) => {
    const isFullWidth = variant === "fullWidth" || variant === "inverse_fullWidth";
    const isInverse = variant === "inverse" || variant === "inverse_fullWidth";
    const listRef = React4.useRef(null);
    const scrollableRef = React4.useRef(null);
    const { determineElementsOutOfBounds, elementOutOBoundsLeft, elementOutOBoundsRight } = useElementsOutOfBounds();
    const { handleShadow, showShadow } = useShowShadow();
    const handleScrollEvent = () => {
      handleShadow();
      determineElementsOutOfBounds(scrollableRef.current, listRef.current);
    };
    React4.useEffect(() => {
      if (listRef.current && scrollableRef.current) {
        const currentSelectedTab = listRef.current.querySelector(`[aria-current="page"]`);
        const scrollableWidth = scrollableRef.current.getBoundingClientRect().width;
        if (currentSelectedTab && (currentSelectedTab?.getBoundingClientRect().x < 0 || currentSelectedTab?.getBoundingClientRect().right > scrollableWidth)) {
          const scrollLeft = currentSelectedTab.getBoundingClientRect().x - scrollableRef.current.getBoundingClientRect().x;
          scrollableRef.current.scrollLeft += scrollLeft;
        }
        scrollableRef.current?.addEventListener("scroll", handleScrollEvent);
        window.addEventListener("resize", handleScrollEvent);
        determineElementsOutOfBounds(scrollableRef.current, listRef.current);
      }
    }, [listRef.current, scrollableRef.current]);
    React4.useEffect(() => {
      return () => {
        if (scrollableRef.current) {
          scrollableRef.current.removeEventListener("scroll", handleScrollEvent);
          window.removeEventListener("resize", handleScrollEvent);
        }
      };
    }, []);
    if (orientation === "vertical") {
      return /* @__PURE__ */ React4.createElement(InPageNavigationContext.Provider, { value: { variant, orientation } }, /* @__PURE__ */ React4.createElement(Box2, { ...safelySpreadBoxProps(props), as: "nav", ref, element }, /* @__PURE__ */ React4.createElement(
        Box2,
        {
          as: "ul",
          listStyleType: "none",
          element: `${element}_ITEMS`,
          display: "flex",
          flexDirection: "column",
          margin: "space0",
          padding: "space0",
          width: "100%",
          rowGap: "space20"
        },
        children
      )));
    }
    if (isFullWidth) {
      return /* @__PURE__ */ React4.createElement(InPageNavigationContext.Provider, { value: { variant, orientation } }, /* @__PURE__ */ React4.createElement(Box2, { ...safelySpreadBoxProps(props), as: "nav", ref, element }, /* @__PURE__ */ React4.createElement(
        Box2,
        {
          as: "ul",
          listStyleType: "none",
          element: `${element}_ITEMS`,
          display: "flex",
          justifyContent: "space-evenly",
          columnGap: "space0",
          padding: "space0",
          margin: "space0",
          marginBottom: marginBottom || "space60",
          borderBottomWidth: hideBottomBorder ? "borderWidth0" : "borderWidth10",
          borderBottomStyle: hideBottomBorder ? "none" : "solid",
          borderBottomColor: isInverse ? "colorBorderInverseWeaker" : "colorBorderWeaker"
        },
        children
      )));
    }
    return /* @__PURE__ */ React4.createElement(InPageNavigationContext.Provider, { value: { variant, orientation } }, /* @__PURE__ */ React4.createElement(
      Box2,
      {
        ...safelySpreadBoxProps(props),
        as: "nav",
        marginBottom: marginBottom || "space60",
        display: "flex",
        ref,
        element,
        overflow: "hidden"
      },
      /* @__PURE__ */ React4.createElement(
        OverflowButton,
        {
          position: "left",
          onClick: () => handleScrollDirection("left", elementOutOBoundsLeft, elementOutOBoundsRight, scrollableRef.current),
          visible: Boolean(elementOutOBoundsLeft),
          element,
          showShadow
        }
      ),
      /* @__PURE__ */ React4.createElement(
        Box2,
        {
          as: StyledScrollWrapper,
          display: "flex",
          flexWrap: "nowrap",
          element: `${element}_SCROLL_WRAPPER`,
          overflowX: "auto",
          overflowY: "hidden",
          flexGrow: 1,
          ref: scrollableRef
        },
        /* @__PURE__ */ React4.createElement(
          Box2,
          {
            as: "ul",
            ref: listRef,
            listStyleType: "none",
            element: `${element}_ITEMS`,
            display: "flex",
            flexGrow: 1,
            justifyContent: "flex-start",
            padding: "space0",
            margin: "space0",
            columnGap: "space50",
            borderBottomWidth: hideBottomBorder ? "borderWidth0" : "borderWidth10",
            borderBottomStyle: hideBottomBorder ? "none" : "solid",
            borderBottomColor: isInverse ? "colorBorderInverseWeaker" : "colorBorderWeaker"
          },
          children
        )
      ),
      /* @__PURE__ */ React4.createElement(
        OverflowButton,
        {
          position: "right",
          onClick: () => handleScrollDirection("right", elementOutOBoundsLeft, elementOutOBoundsRight, scrollableRef.current),
          visible: Boolean(elementOutOBoundsRight),
          element,
          showShadow
        }
      )
    ));
  }
);
InPageNavigation.displayName = "InPageNavigation";

// src/InPageNavigationItem.tsx
import { secureExternalLink } from "@twilio-paste/anchor";
import { Box as Box3, safelySpreadBoxProps as safelySpreadBoxProps2 } from "@twilio-paste/box";
import * as React5 from "react";
var BASE_STYLES = {
  color: "colorTextWeak",
  minWidth: "sizeSquare130",
  textAlign: "center",
  fontSize: "fontSize30",
  fontWeight: "fontWeightMedium",
  overflow: "hidden",
  position: "relative",
  textOverflow: "ellipsis",
  transition: "border-color 100ms ease, color 100ms ease",
  whiteSpace: "nowrap",
  textDecoration: "none",
  _hover: {
    borderBottomColor: "colorBorderPrimaryStronger",
    borderLeftColor: "colorBorderPrimaryStronger",
    color: "colorTextLinkStronger"
  },
  _focus: {
    boxShadow: "shadowFocusInset",
    outline: "none",
    borderRadius: "borderRadius20"
  }
};
var HORIZONTAL_BASE_STYLES = {
  ...BASE_STYLES,
  width: "100%",
  display: "block",
  borderBottomColor: "transparent",
  borderBottomStyle: "solid",
  borderBottomWidth: "borderWidth10",
  paddingBottom: "space40",
  paddingLeft: "space30",
  paddingRight: "space30",
  paddingTop: "space40",
  borderTopLeftRadius: "borderRadius30",
  borderTopRightRadius: "borderRadius30",
  _focus: {
    borderTopLeftRadius: "borderRadius30",
    borderTopRightRadius: "borderRadius30",
    boxShadow: "shadowFocusInset",
    outline: "none"
  }
};
var VERTICAL_BASE_STYLES = {
  ...BASE_STYLES,
  width: "auto",
  display: "block",
  borderLeftColor: "transparent",
  borderLeftStyle: "solid",
  borderLeftWidth: "borderWidth10",
  paddingBottom: "space30",
  paddingTop: "space30",
  paddingLeft: "space50",
  paddingRight: "space50",
  borderBottomRightRadius: "borderRadius30",
  borderTopRightRadius: "borderRadius30",
  whiteSpace: "break-spaces",
  _focus: {
    boxShadow: "shadowFocusInset",
    outline: "none",
    borderTopRightRadius: "borderRadius30",
    borderBottomRightRadius: "borderRadius30"
  }
};
var CURRENT_PAGE_STYLES = {
  borderBottomColor: "colorBorderPrimary",
  borderLeftColor: "colorBorderPrimary",
  color: "colorTextLink",
  _focus: {
    borderBottom: "none",
    boxShadow: "shadowFocusInset",
    outline: "none"
  }
};
var INVERSE_STYLES = {
  color: "colorTextInverseWeaker",
  _focus: {
    boxShadow: "shadowFocusInverseInset",
    outline: "none"
  },
  _hover: {
    borderBottomColor: "colorBorderInverse",
    borderLeftColor: "colorBorderInverse",
    color: "colorTextInverseWeaker"
  }
};
var INVERSE_CURRENT_PAGE_STYLES = {
  borderBottomColor: "colorBorderInverseStrong",
  borderLeftColor: "colorBorderInverseStrong",
  color: "colorTextInverse",
  _focus: {
    borderBottom: "none",
    boxShadow: "shadowFocusInverseInset",
    outline: "none"
  }
};
var InPageNavigationItem = React5.forwardRef(
  ({ element = "IN_PAGE_NAVIGATION_ITEM", currentPage = false, href, children, title, ...props }, ref) => {
    const { variant, orientation } = React5.useContext(InPageNavigationContext);
    const isFullWidth = variant === "fullWidth" || variant === "inverse_fullWidth";
    const isInverse = variant === "inverse" || variant === "inverse_fullWidth";
    let currentPageStyles = {};
    if (currentPage) {
      if (isInverse)
        currentPageStyles = INVERSE_CURRENT_PAGE_STYLES;
      else
        currentPageStyles = CURRENT_PAGE_STYLES;
    }
    if (orientation === "vertical") {
      return /* @__PURE__ */ React5.createElement(Box3, { as: "li", ref, element, minWidth: "size0", marginBottom: "space20" }, /* @__PURE__ */ React5.createElement(
        Box3,
        {
          ...secureExternalLink(href),
          ...safelySpreadBoxProps2(props),
          ...VERTICAL_BASE_STYLES,
          ...isInverse ? INVERSE_STYLES : {},
          ...currentPageStyles,
          as: "a",
          ref,
          element: `${element}_ANCHOR`,
          "aria-current": currentPage ? "page" : void 0,
          href,
          width: "100%",
          textAlign: "start",
          title
        },
        children
      ));
    }
    return /* @__PURE__ */ React5.createElement(
      Box3,
      {
        as: "li",
        ref,
        element,
        display: "flex",
        flexBasis: isFullWidth ? "100%" : void 0,
        flexGrow: isFullWidth ? 1 : void 0,
        flexShrink: isFullWidth ? 1 : void 0,
        minWidth: "size0"
      },
      /* @__PURE__ */ React5.createElement(
        Box3,
        {
          ...secureExternalLink(href),
          ...safelySpreadBoxProps2(props),
          ...HORIZONTAL_BASE_STYLES,
          ...isInverse ? INVERSE_STYLES : {},
          ...currentPageStyles,
          as: "a",
          ref,
          element: `${element}_ANCHOR`,
          "aria-current": currentPage ? "page" : void 0,
          href,
          title
        },
        children
      )
    );
  }
);
InPageNavigationItem.displayName = "InPageNavigationItem";
export {
  InPageNavigation,
  InPageNavigationItem
};
