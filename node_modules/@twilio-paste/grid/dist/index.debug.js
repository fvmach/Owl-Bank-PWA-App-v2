"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  Column: () => Column,
  Grid: () => Grid
});
module.exports = __toCommonJS(src_exports);

// src/Grid.tsx
var import_box = require("@twilio-paste/box");
var React = __toESM(require("react"));

// src/utils.tsx
var initDefaultSpacing = ({
  prefix,
  responsive,
  defaultValue
}) => {
  const getSpaceDefault = () => responsive ? new Array(3).fill(defaultValue) : defaultValue;
  return {
    [`${prefix}Top`]: getSpaceDefault(),
    [`${prefix}Bottom`]: getSpaceDefault(),
    [`${prefix}Right`]: getSpaceDefault(),
    [`${prefix}Left`]: getSpaceDefault()
  };
};
var getDefaultSpacingValue = (prefix) => prefix === "margin" ? "auto" : "space0";
var getSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const computedSpacing = initDefaultSpacing({ prefix, responsive: false, defaultValue });
  if (spacing === void 0) {
    return computedSpacing;
  }
  if (vertical) {
    computedSpacing[`${prefix}Top`] = spacing;
    computedSpacing[`${prefix}Bottom`] = spacing;
  } else {
    computedSpacing[`${prefix}Right`] = spacing;
    computedSpacing[`${prefix}Left`] = spacing;
  }
  return computedSpacing;
};
var getResponsiveSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const styles = {
    [`${prefix}Top`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Bottom`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Right`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Left`]: [defaultValue, defaultValue, defaultValue]
  };
  const spacingIsEmptyArray = Array.isArray(spacing) && spacing.length === 0;
  if (spacing === void 0 || spacingIsEmptyArray) {
    return styles;
  }
  vertical.forEach((isVertical, screenSize) => {
    const spacingForScreenSize = Array.isArray(spacing) ? spacing[screenSize] : spacing;
    if (isVertical) {
      styles[`${prefix}Top`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Bottom`][screenSize] = spacingForScreenSize;
    } else {
      styles[`${prefix}Right`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Left`][screenSize] = spacingForScreenSize;
    }
  });
  return styles;
};
var getOuterGutterPull = (gutter) => {
  if (Array.isArray(gutter)) {
    return gutter.map((value) => {
      if (value !== "space0") {
        return value.replace("space", "spaceNegative");
      }
      if (value === "space0") {
        return "space0";
      }
      return null;
    });
  }
  if (gutter === "space0") {
    return "space0";
  }
  if (gutter && typeof gutter === "string") {
    return gutter.replace("space", "spaceNegative");
  }
  return "auto";
};
var getStackedColumns = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "100%" : "0";
      }
      return null;
    });
  }
  if (vertical) {
    return "100%";
  }
  return "0";
};
var getColumnPadding = ({ vertical, gutter }) => {
  return Array.isArray(vertical) ? getResponsiveSpacing(vertical, "padding", gutter) : getSpacing(vertical, "padding", gutter);
};
var getColumnSpan = ({ count, span }) => {
  if (Array.isArray(span) && count) {
    return span.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  if (typeof span === "number" && count && count <= 12) {
    return `${span / 12 * 100}%`;
  }
  if (count !== void 0) {
    return `${1 / count * 100}%`;
  }
  return `${1 / 12 * 100}%`;
};
var getColumnOffset = (offset) => {
  if (Array.isArray(offset)) {
    return offset.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  return `${offset / 12 * 100}%`;
};

// src/Grid.tsx
var getGutterStyles = (gutter, vertical = false) => {
  const margin = getOuterGutterPull(gutter);
  if (Array.isArray(vertical)) {
    return getResponsiveSpacing(vertical, "margin", margin);
  }
  return getSpacing(vertical, "margin", margin);
};
var getFlexDirection = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "column" : "row";
      }
      return "row";
    });
  }
  if (vertical) {
    return "column";
  }
  return "row";
};
var Grid = React.forwardRef(
  ({ as, children, element = "GRID", equalColumnHeights, gutter, marginTop, marginBottom, vertical = false, ...props }, ref) => {
    const GridColumns = React.useMemo(
      () => React.Children.map(
        children,
        (child) => React.isValidElement(child) ? React.cloneElement(child, {
          count: React.Children.count(children),
          gutter,
          vertical,
          stretchColumnContent: equalColumnHeights
        }) : child
      ),
      [children, vertical, equalColumnHeights, gutter]
    );
    const gutterStyles = React.useMemo(() => getGutterStyles(gutter, vertical), [gutter, vertical]);
    const flexDirection = React.useMemo(() => getFlexDirection(vertical), [vertical]);
    return /* @__PURE__ */ React.createElement(
      import_box.Box,
      {
        ...(0, import_box.safelySpreadBoxProps)(props),
        ref,
        as,
        alignItems: equalColumnHeights ? "stretch" : null,
        element,
        flexDirection,
        flexWrap: "wrap",
        display: "flex",
        ...gutterStyles,
        marginTop,
        marginBottom,
        minWidth: "size0",
        rowGap: props.rowGap,
        columnGap: props.columnGap
      },
      GridColumns
    );
  }
);
Grid.displayName = "Grid";

// src/Column.tsx
var import_box2 = require("@twilio-paste/box");
var React2 = __toESM(require("react"));
var getColumnStyles = ({
  count,
  span,
  gutter,
  offset,
  vertical,
  stretchColumnContent
}) => {
  const columnStyles = {
    width: getColumnSpan({ count, span }),
    ...getColumnPadding({ gutter, vertical })
  };
  if (offset) {
    columnStyles.marginLeft = getColumnOffset(offset);
  }
  if (vertical && !offset) {
    columnStyles.minWidth = getStackedColumns(vertical);
    columnStyles.marginLeft = "space0";
  }
  if (stretchColumnContent) {
    columnStyles.alignContent = "stretch";
    columnStyles.display = "flex";
  }
  return columnStyles;
};
var Column = React2.forwardRef(
  ({ as, children, count, element = "COLUMN", gutter, offset, span, stretchColumnContent, vertical, ...props }, ref) => {
    const ColumnStyles = React2.useMemo(
      () => getColumnStyles({ count, gutter, offset, span, stretchColumnContent, vertical }),
      [count, gutter, offset, span, stretchColumnContent, vertical]
    );
    return /* @__PURE__ */ React2.createElement(import_box2.Box, { ...(0, import_box2.safelySpreadBoxProps)(props), ...ColumnStyles, as, element, ref }, children);
  }
);
Column.displayName = "Column";
